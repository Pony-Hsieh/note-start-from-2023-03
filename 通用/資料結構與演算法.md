# 資料結構與演算法

- How to construct a complete binary tree from given array?

- How to judge if the given param is a full binary tree?

- Max Heap 未必是 sorted array，

## CH 3. Complexity and Big O Notation

### 12. The Idea of Algorithm

### 13. Comparing Algorithms
- We care about how much time it takes for an algorithm to finish a task.
  The less time it takes, the better it is.
  But timing code's runtime is not realistic in terms of analysis. Why?
  1. Same computer gets different runtime for the same task.
  2. Different computing power machine gives different run time for the same task.
  3. We care about space as well, but not as much as time in this course.
- 為了建立相同的比較基準，所以採用 "步驟數量" 作為比較基準
- 同樣都能解決問題，但是解決問題的方法不同
    - 範例：
      ```javascript
        function fn1(n) {
            let sum = 0;
            for (let i = 1; i <= n; i++) {
                sum += i;
            }
            return sum;
        }

        function fn2(n) {
            return (1 + n) * n / 2;
        }

        console.log("fn1", fn1(100)); // 5050
        console.log("fn2", fn2(100)); // 5050
      ```
      
### 14. Complexity
- Complexity means given an input size, "how many operations do we need to perform in an algorithm?"
- 如何分析演算法的複雜度(complexity)？
    1. 時間複雜度 (time complexity)
        - 由於現在記憶體空間通常都很夠，所以目前基本上以分析時間複雜度為主
    2. 空間複雜度 (space complexity)
- Generally, every addition(加法), subtraction(減法), multiplication(乘法), division(除法), comparison(比較) counts as one "operation".
- When analyzing the complexity of an algorithm, we calculate the time or space complexity.
- We use f(n) to show the equation of complecity and input sizes.
    - 範例：
      ```javascript
        function example(n) {
            for (let i = 0; i < 3 * n; i++) {
                console.log("Hello");
            }

            for (let i = 0; i < n; i++) {
                for (let j = 0; j < n; j++) {
                    console.log("Hello");
                }
            }

            console.log("Hello");
            console.log("Hello");
            console.log("Hello");
            console.log("Hello");
        }

        // f(n) = 3n + n^2 + 4
      ```
      
### 15. Analysis of fun 1 and fun 2 
- 範例：
  ```javascript
    function fn1(n) {
        let sum = 0;
        for (let i = 1; i <= n; i++) {
            sum += i;
        }
        return sum;
    }
    // O(n) = 3n


    function fn2(n) {
        return (1 + n) * n / 2;
    }
    // O(n) = 3
  ```

### 16. Big O Notation
- Big O Notation is a tool that describe the limiting behavior of a function when the argument tends towards a particular value or infinity.
    - 當傳入一個函式的參數很大(或很小)的時候，這個函式的走向趨勢為何？
- Big O Notation has a "worst case scenario", which means it shows the general trends of complexity when the size of inputs is extremely large.
    - Big O Notation 會考慮最糟狀況
- 如何計算 Big O Notation？
    1. 拿掉 常數(constant)
        - 常數 相對於 變數(variable)
        - 範例：
            - f(n) = 3n → O(n)
    2. 只留最高次方項
        - 範例：
            - f(n) = 3n^2 + 6n + 4 → O(n^2)
    3. 拿掉 底數(logarithm base)
        - 範例：
            - f(n) = log₂ⁿ → O(log n)
- 常見的演算法複雜度：
    - 1~8 → 好~壞
    1. O(1)
    2. O(logⁿ)
    3. O(n)
    4. O(n * logⁿ)
    5. O(n^2)
    6. O(n^3)
    7. O(2^n)
    8. O(n!)

### 20. Big O in Arrays and Objects
- Object
    - insertion(新增) → O(1)
    - removal(刪除) → O(1)
    - searching(查找) → O(n)
    - accessing(取用) → O(1)
        - 因為 JS 的 物件、陣列(可以視為物件的特化型)，皆採用 hash table (雜湊表) 儲存資料，所以 accessing 時的 Big O Notation 為 1
    - searching 和 accessing 的差異是甚麼？
- Array
    - insertion(新增) 
        - push (插入於陣列尾端) → O(1)
        - unshift (插入於陣列開頭) → O(n)
            - 因為每個元素的 index 都要再 + 1
    - removal(刪除) → O(1)
        - pop (移除陣列尾端的資料) → O(1)
        - unshift (移除陣列開頭的資料) → O(n)
            - 因為每個元素的 index 都要再 - 1
    - searching(查找) → O(n)
    - accessing(取用) → O(1)
        - 因為 JS 的 物件、陣列(可以視為物件的特化型)，皆採用 hash table (雜湊表) 儲存資料，所以 accessing 時的 Big O Notation 為 1
## ------------------------------------------------------------------------



## CH 4. Introduction to Algorithm Design

### 22. Chapter Introduction

### 23. Linear Search (Sequential Search)
- 所有陣列皆可用
- It's an algorithm that sequential checks each element of the list until a match is found, or the whole list has been searched
    - 這個演算法會依序查找每個元素，直到
        1. 找到目標元素
        2. 整個 list 都被找完
    - 範例：
      試著在陣列中找到指定的數字。
      如果有找到，回傳該數字的 index；
      如果沒有找到，則回傳 -1
      ```javascript
        const numberArr = [95, 96, 97, 98, 99, 100];

        function findNumber(arr, target) {
            for (let i = 0; i < arr.length; i++) {
                if (arr[i] === target) {
                    return i;
                }
            }
            return -1;
        }

        // console.log("findNumber", findNumber(numberArr, 95)); // 0
        // console.log("findNumber", findNumber(numberArr, 100)); // 5
        // console.log("findNumber", findNumber(numberArr, 90)); // -1
      ```
    - 演算法分析：
        - Worst Case Performance: O(n)
        - Best Case Performance: O(1)
        - Average Case Performance: O(n/2)
        - 時間複雜度為： O(n)

### 24. Binary Search
- 僅能用於 sorted array
    - 範例：
      試著在陣列中找到指定的數字。
      如果有找到，回傳該數字的 index；
      如果沒有找到，則回傳 -1
      ```javascript
        const numbers = [9, 12, 15, 18, 19, 20, 22, 25, 26, 26, 33, 37, 38, 41, 47, 47, 50, 55, 57, 60, 68, 80, 87, 90, 98, 100, 103, 108, 109, 109, 116, 120, 120, 124, 127, 128, 131, 135, 135, 139, 143, 145, 151, 155, 156, 158, 163, 164, 165, 169, 169, 173, 174, 176, 177, 178, 181, 182, 182, 183, 184, 189, 192, 195, 200, 201, 203, 204, 207, 213, 217, 222, 222, 222, 227, 228, 233, 235, 237, 239, 239, 243, 248, 251, 252, 257, 260, 260, 263, 268, 270, 271, 271, 276, 281, 284, 285, 295, 297, 298,];

        function binarySearch(arr, target) {
            let minIndex = 0;
            let maxIndex = arr.length - 1;

            while (minIndex <= maxIndex) {
                const middleIndex = Math.floor((minIndex + maxIndex) / 2);

                if (target === arr[middleIndex]) {
                    return middleIndex;
                }
                else if (target > arr[middleIndex]) {
                    minIndex = middleIndex + 1;
                }
                else if (target < arr[middleIndex]) {
                    maxIndex = middleIndex - 1;
                }
            }

            return -1;
      ```
     - 演算法分析：
        - Worst Case Performance: O(logⁿ)
        - Best Case Performance: O(1)
        - Average Case Performance: O(logⁿ)
        - 時間複雜度為： O(logⁿ)

### 25. General Guide of Algorithm Design

### 26. Intersection Problem
- 試著找到兩個陣列的交集
    - 解法 1
      ```javascript
        const arr1 = [1, 3, 7];
        const arr2 = [16, 5, 1, 3];

        function findIntersection(arr1, arr2) { // intersection 在數學中為 "交集"
            const res = [];

            for (let i = 0; i < arr1.length; i++) {
                for (let j = 0; j < arr2.length; j++) {
                    if (arr1[i] === arr2[j]) {
                        res.push(arr1[i]);
                    }
                }
            }

            // console.log("res", res);
        }

        // findIntersection(arr1, arr2);
      ```
         - 演算法分析：
            - 時間複雜度為： O(n^2)

### 27. Counter
- 試著找到兩個陣列的交集
    - 解法 2 (解法 1 在 ### 25. Intersection Problem)
      ```javascript
        const arr1 = [1, 3, 7];
        const arr2 = [16, 5, 1, 3];

        function findIntersection(arr1, arr2) { // intersection 在數學中為 "交集"
            const res = [];
            const checkMap = new Map();

            // 將 arr1 內的所有元素加入至 map 中，並將值設定為 1
            for (let i = 0; i < arr1.length; i++) {
                checkMap.set(arr1[i], 1);
            }

            // 如果 arr2 內的元素有出現在 map 中，則將值設定為 2
            for (let i = 0; i < arr2.length; i++) {
                if (checkMap.has(arr2[i])) {
                    checkMap.set(arr2[i], 2);
                }
            }

            // 檢查 map 中 value 為 2 的元素，即為兩陣列交集的元素
            for (let [key, value] of checkMap) {
                // console.log(`The value of ${key} in Map is ${value}`);
                if (value === 2) {
                    res.push(key);
                }
            }

            // console.log("res", res);
        }

        // findIntersection(arr1, arr2);
      ```
         - 演算法分析：
            - 時間複雜度為： O(n)
        - 補充
            - Map 和 物件（Object）很相似，但是有以下幾點差別：
                - Map 的 key 是唯一的，如果 set 到重複的 key，則舊的 value 會被覆蓋
                - Map 中的 key 會依據被添加資料的時間而有順序性，Object 則沒有
                - Object 的 key 只能是 字串（String）或 Symbol，而 Map 的 key 可以是任何值，包含物件、函式或原始型別（primitive type）
                - 要取得 Map 的大小非常容易，只需要取得 size 屬性即可；
                  而 Object 的大小必須手動決定
                - 當需要經常增添刪減屬性時，使用 Map 的效能會比 Object 來得好
                - ES6 中如果希望「陣列（Array）」的元素不會重複，可以使用 Set；
                  如果是希望「物件（Object）」的鍵不會重複，則可以使用 Map
                - 創建、新增、修改、刪除
                    - 創建 Map
                      ```javascript
                        const myMap = new Map();
                      ```
                    - 新增、修改 Map 某個 key 的 value
                      ``` javascript
                        myMap.set(0, "zero");
                      ```
                    - 取得 Map 某個 key 的 value
                      ``` javascript
                        myMap.get(0);
                      ```
                    - 檢查 Map 是否具有某個 key
                      ``` javascript
                        myMap.has(0);
                      ```
                    - 刪除 Map 某個 key 的 value
                      ```javascript
                        myMap.delete(0);
                      ```
                    - 清空整個 Map
                      ```javascript
                        myMap.clear(); 
                      ```
                - 取所有值
                    - 取得所有 key
                      ```javascript
                        myMap.keys();
                      ```
                    - 取得所有 value
                      ```javascript
                        myMap.values(); 
                      ```
                    - 取得所有 key、value
                      ```javascript
                        myMap.entires(); 
                      ```
                - 疊代 
                    - 疊代 key
                      ```javascript
                        for (let key of myMap.keys()) {
                            console.log(key);
                        }
                      ```
                    - 疊代 value
                      ```javascript
                        for (let value of myMap.values()) {
                            console.log(value);
                        }
                      ```
                    - 疊代 所有 key、value
                      ```javascript
                        for (let [key, value] of myMap) {
                            console.log(`The value of ${key} in Map is ${value}`);
                        }
                      ```
                - 範例：
                  ```javascript
                    // 創建 Map
                    const myMap = new Map();

                    // 新增、修改 Map 某個 key 的 value
                    myMap.set(0, "zero"); // 新增
                    myMap.set(1, "zero"); // 新增
                    myMap.set(1, "one"); // 修改
                    myMap.set(2, "two"); // 新增
                    // console.log("myMap", myMap);

                    // 取得 Map 某個 key 的 value // 回傳該 key 的 value？
                    // console.log(myMap.get(0)); // zero

                    // 檢查 Map 是否具有某個 key // 回傳 true 或 false
                    // console.log(myMap.has(0)); // true

                    // 成功刪除回傳 true，否則回傳 false (例如刪除一個不存在的 key，就會回傳 false)
                    // myMap.delete(0);
                    // console.log(myMap.delete(0));

                    // 清空整個 Map // 回傳 undefined (還是其實這是沒有回傳值的意思？)
                    // myMap.clear(); 
                    // console.log(myMap.clear());


                    // 取得所有 key
                    // console.log("myMap.keys()", myMap.keys()); // MapIterator

                    // 取得所有 value
                    // console.log("myMap.values()", myMap.values()); // MapIterator

                    // 取得所有 key、value
                    // console.log("myMap", myMap); // Map
                    // console.log("myMap.entries()", myMap.entries()); // MapIterator
                    // console.log(myMap.entries() === myMap); // false


                    // 疊代 key
                    // for (let key of myMap.keys()) {
                    //     console.log(key);
                    // }

                    // 疊代 value
                    // for (let value of myMap.values()) {
                    //     console.log(value);
                    // }

                    // 疊代 key、value
                    // for (let [key, value] of myMap) {
                    //     console.log(`The value of ${key} in Map is ${value}`);
                    // }

                    // 取得 object、map 的大小
                    // const object1 = {
                    //     "rajnish": "singh",
                    //     "sanjeev": "sharma",
                    //     "suraj": "agrahari",
                    //     "yash": "khandelwal"
                    // };
                    // const count = Object.keys(object1).length;
                    // console.log(count);


                    // const checkMap1 = new Map();
                    // checkMap1.set("rajnish", "singh");
                    // checkMap1.set("sanjeev", "sharma");
                    // checkMap1.set("suraj", "agrahari");
                    // checkMap1.set("yash", "khandelwal");
                    // console.log(checkMap1.size);

                  ```

### 28. Coding Practice - Frequency Problem
- 範例：
  判斷兩個字串是否由相同的字母(同字母須數量相同)構成
  ```javascript
    function findIntersection(str1, str2) {
        if (str1.length !== str2.length) {
            return false;
        }

        const checkMap1 = new Map();
        const checkMap2 = new Map();

        // 將 str1 內的每個字母加入至 Map 中
        for (let i = 0; i < str1.length; i++) {
            if (checkMap1.has(str1[i])) {
                checkMap1.set(str1[i], checkMap1.get(str1[i]) + 1);
            }
            else {
                checkMap1.set(str1[i], 1);
            }
        }

        // 將 str2 內的每個字母加入至 Map 中
        for (let i = 0; i < str2.length; i++) {
            if (checkMap2.has(str2[i])) {
                checkMap2.set(str2[i], checkMap2.get(str2[i]) + 1);
            }
            else {
                checkMap2.set(str2[i], 1);
            }
        }

        // console.log("checkMap1", checkMap1);
        // console.log("checkMap2", checkMap2);

        // 檢查兩個 Map 的構成是否相同
        for (let [key, value] of checkMap1) { // Map 可以疊代，所以可以用 for of
            if (checkMap2.has(key)) {
                if (checkMap1.get(key) !== checkMap2.get(key)) {
                    return false;
                }
            }
            else {
                return false;
            }
        }

        return true;
    }

    // console.log("findIntersection", findIntersection("zxzcz", "xczzz")); // true
    // console.log("findIntersection", findIntersection("aabc", "abab")); // false
  ```

### 29. Coding Practice - Average Pair (好像還沒上)

### 30. Pointer
- 範例：
  給定一個皆為整數的 sorted array，以及一個數字。
  試著找出陣列中是否有兩個數字的平均恰好為為給定的數字
  (不一定只有一對，可能有多對)
  ```javascript
    function findAveragePair(arr, avgParam) {

        const res = [];

        let lP = 0; // 第一項 // left pointer
        let rP = arr.length - 1; // 最後一項 // right pointer

        while (lP < rP) {

            const tempAvg = (arr[lP] + arr[rP]) / 2;

            if (tempAvg === avgParam) { // 代表這組剛好是要找的 pair
                res.push([arr[lP], arr[rP]]);
                lP++;
                rP--;
            }
            else if (tempAvg > avgParam) { // 代表這組的平均值 > avgParam，將 rP 左移一格
                rP--;
            }
            else if (tempAvg < avgParam) { // 代表這組的平均值 < avgParam，將 lP 右移一格
                lP++;
            }
            /* 
                因為是由小到大的 sorted array；
                所以左移的話，整組的平均值會變小(或不變)；
                右移的話，整組的平均值會變大(或不變)
            */
        }
        console.log("res", res);
    }

    const arr = [-11, 0, 1, 2, 3, 9, 14, 17, 21];
    findAveragePair(arr, 1.5); // [[-11, 14], [0, 3], [1, 2]]
  ```
    - 演算法分析：
        - 時間複雜度為： O(n)

### 31. Coding Practice - Palindrome
- 範例：
  檢查傳入的字串是否為回文
  ```javascript
    function isPalindrome(str) {
        let lP = 0; // 第一項 // left pointer
        let rP = str.length - 1; // 最後一項 // right pointer

        while (lP < rP) {
            if (str[lP] === str[rP]) {
                lP++;
                rP--;
            }
            else {
                return false;
            }
        }
        /* 
            不用檢查 lP = rP 的狀況是因為，
            如果 lP = rP 的話，那 str[lP] 和 str[rP] 必相等，
            所以可以不用檢查
        */

        return true;
    }

    // console.log("isPalindrome('aazxcxzaa')", isPalindrome('aazxcxzaa')); // true
    // console.log("isPalindrome('zxcvb')", isPalindrome('zxcvb')); // false
    // console.log("isPalindrome('tacocat')", isPalindrome('tacocat')); // true
    // console.log("isPalindrome('zxccxz')", isPalindrome('zxccxz')); // true
  ```

### 32. Subsequence Problem
- 範例：
  A subsequence of a string is a new string that is formed from the original string by deleting some (can be none) of the characters without disturbing the relative positions of the remaining characters.
  
  isSubsequence("Hello", "Hello World"); // true
  isSubsequence("abc", "bac"); // false
  ```javascript
    function isSubsequence(str1, str2) { // str1 較短、str2 較長
        if (str1.length === 0) {
            return true;
        }

        let p1 = 0;
        let p2 = 0;

        while (p2 < str2.length) { // 當我還沒檢查完 str2 時
            if (str1[p1] === str2[p2]) {
                p1++;
            }
            if (p1 >= str1.length) { // 代表已經檢查完 str1
                return true;
            }
            p2++;
        }

        return false;
    }

    // console.log(isSubsequence("Hello", "Hello World")); // true
    // console.log(isSubsequence("abc", "bac")); // false
    // console.log(isSubsequence("book", "brooklyn")); // true
  ```
  
### 33. Sliding Window
- 範例：
  Write two functions that calculate the max and min sum of n consecutive numbers in an array.
- 老師的寫法是 O(n^2)，剛剛看文章，好像有機會
- 等等可以拿一個有 100 個元素的陣列來測試，看看可不可以成功的降低演算法時間複雜度。
- [Leetcode 刷題 pattern - Sliding Window](https://blog.techbridge.cc/2019/09/28/leetcode-pattern-sliding-window/)
- 老師提供的解法
  ```javascript
    function maxSum(arr, size) {
        let maxValue = -Infinity;
        if (size > arr.length) {
            return null;
        }
        for (let i = 0; i < arr.length - size; i++) {
            let temp = 0;
            for (let j = i; j < i + size; j++) {
                temp += arr[j];
            }
            if (temp > maxValue) {
                maxValue = temp;
            }
        }
        return maxValue;
    }
  ```
- 依據文章改良老師的解法
  ```javascript
    function maxSumPlus(arr, size) {

        if (size > arr.length) {
            return null;
        }

        let maxValue = -Infinity;

        // 先算出第一個 window 的總和
        let init = 0;
        for (let i = 0; i < size; i++) {
            init += arr[i];
        }
        if (init > maxValue) {
            maxValue = init;
        }
        // console.log("init", init); // 12


        for (let i = 1; i < arr.length - size; i++) {
            // 因為第一個 window 已經算過了，所以這邊就不算了
            let total = init - arr[i - 1] + arr[i + size - 1];
            // console.log("total", total);
            if (total > maxValue) {
                maxValue = total;
            }
        }

        return maxValue;
    }
  ```
  ```javascript
    const arr = [];
        for (let i = 0; i < 10000; i++) {
            arr.push(i);
        }
        // const arr = [2, 7, 3, 0, 6, 1, -5, -12, -11, 100];
        console.log("arr", arr);

        // 老師提供的解法
        function maxSum(arr, size) {
            let step = 0;
            let maxValue = -Infinity;
            if (size > arr.length) {
                return null;
            }
            for (let i = 0; i <= arr.length - size; i++) {
                let temp = 0;
                for (let j = i; j < i + size; j++) {
                    step++;
                    temp += arr[j];
                }
                if (temp > maxValue) {
                    maxValue = temp;
                }
            }
            console.log("size", size);
            console.log("maxSum step", step);
            console.log("divide", `${step / size}`);
            return maxValue;
        }

        // 依據文章改良老師的解法
        function maxSumP(arr, size) {
            let step = 0;

            if (size > arr.length) {
                return null;
            }

            let maxValue = -Infinity;

            // 先算出第一個 window 的總和
            let init = 0;
            for (let i = 0; i < size; i++) {
                step++;
                init += arr[i];
            }
            if (init > maxValue) {
                maxValue = init;
            }

            for (let i = 1; i <= arr.length - size; i++) {
                step++;
                let total = init - arr[i - 1] + arr[i + size - 1];
                init = total;
                if (total > maxValue) {
                    maxValue = total;
                }
            }

            // console.log("init", init);
            // console.log("maxValue", maxValue);
            console.log("size", size);
            console.log("maxSumP step", step);
            console.log("divide", `${step / size}`);
            return maxValue;
        }

        console.log("maxSum()", maxSum(arr, 3));
        console.log("---------------------------");
        console.log("maxSumP()", maxSumP(arr, 3));
        console.log("---------------------------");
        console.log("---------------------------");
        console.log("---------------------------");

        console.log("maxSum()", maxSum(arr, 5));
        console.log("---------------------------");
        console.log("maxSumP()", maxSumP(arr, 5));
        console.log("---------------------------");
        console.log("---------------------------");
        console.log("---------------------------");

        console.log("maxSum()", maxSum(arr, 80));
        console.log("---------------------------");
        console.log("maxSumP()", maxSumP(arr, 80));
        console.log("---------------------------");
        console.log("---------------------------");
        console.log("---------------------------");
    ```

### 35. Coding Practice - Min Sub Array
-

### 36. Coding Practice - Unique Letter Substring
- 同 LeetCode 3. Longest Substring Without Repeating Characters
  ```javascript
    function lengthOfLongestSubstring(s) {

        if (s === "") {
            return 0;
        }

        let lp = 0; // left pointer
        let rp = 0; // right pointer

        let maxLen = -Infinity;

        while (rp <= s.length - 1) {
            // console.log("lp", lp);
            // console.log("rp", rp);
            const len = rp - lp + 1;
            const subStr = s.slice(lp, lp + len); // slice 含頭不含尾
            // console.log("subStr", subStr);
            const set = new Set(subStr);
            if (set.size === len) { // 代表是 符合條件的 subStr
                if (len > maxLen) {
                    maxLen = len;
                }
                rp++;
            }
            else {
                lp++;
            }
        }

        return maxLen;
    }
  ```

### 38. Recursion
- 定義：A function that calls itself.
- Recursion is using a data structure called "stack". When we are calling a function inside another function, we are on the "call stack".
- Recursion is also a mathemetical relation in sequences(數列).
- 範例：
    - 數學：
      - T(1) = 10
        T(n) = T(n - 1) + 15
    - 程式語言：
      ```javascript
        function recursion(param) {
            if (param === 1) {
                return 10;
            }
            else {
                return recursion(param - 1) + 15;
            }
        }

        // console.log(recursion(1)); // 10
        // console.log(recursion(3)); // 40
      ```
      
### 39. Coding Practice - Fibonacci Sequence
- 範例：
  Write a function that takes an integer N as an input and returns the Nth number in Fibonacci Sequence.
  ```javascript
    function fibonacci(n) {
        if (n === 0) {
            return 0;
        }
        else if (n === 1) {
            return 1;
        }
        else {
            return fibonacci(n - 1) + fibonacci(n - 2);
        }
    }

    // console.log(fibonacci(1)); // 1
    // console.log(fibonacci(4)); // 3
    // console.log(fibonacci(8)); // 21
    // console.log(fibonacci(10)); // 55
  ```
  以 fibonacci(4) 為例：
  
  因為初始條件只有兩個，就是 F(0) = 0, F(1) = 1
  所以要將所有的 F(n) 都代換成這兩個

  F(4) = F(3) + F(2)
    = [F(2) + F(1)] + [F(1) + F(0)]
    = [[F(1) + F(0)] + F(1)] + [F(1) + F(0)]
    = 1 + 0 + 1 + 1 + 0
    = 3

### 40. Coding Practice - Array of Arrays
- 範例：
  試著攤平陣列
    - 解法 1 - 將 res 放在 function 外面
      ```javascript
        const arrs = [[[["a", [["b", ["c"]], ["d"]]], [["e"]], [[["f", "g", "h"]]]]]];

        const res = [];
        function arrCollector(param) {
            for (let i = 0; i < param.length; i++) {
                if (Array.isArray(param[i]) === true) {
                    arrCollector(param[i]);
                }
                else {
                    res.push(param[i]);
                }
            }
        }

        // arrCollector(arrs);
        // console.log("res", res); // ['a', 'b', 'c', 'd', 'e', 'f', 'g', 'h']
      ```
    - 解法 2 - 將 res 放在 function 裡面
      ```javascript
        const arrs = [[[["a", [["b", ["c"]], ["d"]]], [["e"]], [[["f", "g", "h"]]]]]];

        function arrCollector(param1) {
            const res = [];
            helper(param1);
            function helper(param2) {
                for (let i = 0; i < param2.length; i++) {
                    if (Array.isArray(param2[i]) === true) {
                        helper(param2[i]);
                    }
                    else {
                        res.push(param2[i]);
                    }
                }
            }
            console.log("res", res);
        }

        // arrCollector(arrs); // ['a', 'b', 'c', 'd', 'e', 'f', 'g', 'h']
      ```

## ------------------------------------------------------------------------



## CH 5. Sorting Algorithms I

### 41. Intro to Sorting Algorithms
- Even though many modern programming languages have built-in sorting functions, it's still a good thing to know how it works.
- We are going to learn 6 sorting algorithms in this course. It's good to know when to use which algorithm, as they excel in some certain cases.
    - 了解不同演算法的適用情境(例如有些僅限於用在 sorted array)
    - 有些演算法在特定情況下的確 O(n) 比較好，但是脫離特定情況，就無法適用了；
      有些演算法雖然比較慢，但是基本上所有狀況都適用。
      有點像是可以把那些比較慢的演算法當作備案的感覺

### 42. ~ 45. Bubble Sort
- Bubble sort compares adjacent(相鄰的) elements and swaps them if they are in the wrong order.
- 算是極度基礎且效率差的演算法，因此現實生活中基本上沒有在使用這個演算法
- 作法
    1. 先比較最後兩項，一路比較到第二項
       (第一項不能比，因為第一項沒辦法和不存在的第零項比)
       比完後可確保第一項為最小(或最大，看你怎麼設定)
    2. 繼續比較最後兩項，一路比較到第三項
       比完後可確保第二項為次小(或次大，看你怎麼設定)
    3. 依此類推
    4. 以每算一遍，就把排序好的推到最左邊的寫法為例：
       迴圈的外圈是控制，我這次迴圈跑完後，第幾項是正確的
       所以只需要從第一項跑到倒數第二項，因為最後一項也沒得交換；
       迴圈的內圈是控制，我要從迴圈的最後跑到第幾項。
       內外迴圈剛好都不用跑最後一項
- 範例 1
    - 這個作法是每算一遍，就把排序好的推到最左邊，由小排到大
      ```javascript
        function bubbleSort(arr) {
            for (let i = 0; i <= arr.length - 2; i++) { // 跑完迴圈後，陣列的第 i+1 項已經是被排好的 // i is sorted element
                for (let j = arr.length - 1; j >= i + 1; j--) {
                    if (arr[j - 1] > arr[j]) {
                        // 交換 arr[i]、arr[j]
                        const temp = arr[j];
                        arr[j] = arr[j - 1];
                        arr[j - 1] = temp;
                    }
                }
            }
            console.log("arr", arr);
        }

        // bubbleSort([4, 7, 1, 2, 5, 3]);

        // const randomArr = [];
        // for (let i = 0; i < 100; i++) {
        //     randomArr.push(Math.ceil(Math.random() * 100));
        // }
        // console.log("randomArr", randomArr);
        // bubbleSort(randomArr);
      ```
- 範例 2
    - 這個作法是每算一遍，就把排序好的推到最右邊，由小排到大
      ```javascript
        function bubbleSortRightFirst(arr) {
            for (let i = arr.length - 1; i >= 1; i--) {
                let swap_flag = false;
                for (let j = 0; j <= arr.length - 2; j++) {
                    if (arr[j] > arr[j + 1]) {
                        [arr[j], arr[j + 1]] = [arr[j + 1], arr[j]];
                        swap_flag = true;
                    }
                }
                if (swap_flag === false) { // 如果跑完迴圈發現都沒有交換，則中斷迴圈
                    break;
                }
            }
            return arr;
        }

        // console.log(bubbleSortRightFirst([4, 7, 1, 2, 5, 3]));
        // const randomArr = [];
        // for (let i = 0; i < 100; i++) { // 製作內含 1~100 的隨機陣列
        //     randomArr.push(Math.ceil(Math.random() * 100));
        // }
        // console.log("randomArr", randomArr);
        // console.log("bubbleSortRightFirst", bubbleSortRightFirst(randomArr));
      ```
    - 解讀
        - 外層迴圈可以理解為
            1. 要從哪個位置，執行迴圈幾次
               像是這個例子中，就是從最後一個位置(i = arr.length - 1)，一路執行到正數第二個位置(i = 1)
               為什麼只執行到正數第二個位置，而不是正數第一個呢？原因如 2.
            2. 這個迴圈跑完之後，哪個位置之後的是已經被排序好的
               這也可以解釋為什麼不需要執行到 i = 0，因為只剩一個位置，再往前也沒得換了
        - 內層迴圈可以理解為實際執行判斷、交換的函式
        - 在這個寫法中，i、j 的方向必然是反向的
- 範例 3
- 演算法分析：
    - Worst Case Performance: O(n^2)
    - Best Case Performance: O(n)
        - 遍歷陣列內所有元素一次後，發現剛好是都排列好的狀態
          實作上需要搭配 flag，紀錄第一次遍歷後，是否有 swap 過
    - Average Case Performance: O(n^2)
    - 時間複雜度為： O(n^2)
- 其他參考文章：
    - [排序 1 : 排序簡介 & 氣泡排序 Bubble Sort](https://ithelp.ithome.com.tw/articles/10217933)

### 46. ~ 49. Insertion Sort
- Insertion sort is a little bit more efficient than bubble sort in practice. Theoretically, they have the same Big O value.
    - 理論上 insertion sort、bubble sort 兩者的效率差不多，實際上 insertion sort 會再快一點
        - Why?
- The principle of insertion sort is simple. Keeping inserting a new value into a sorted array. Inserted it to the correct spot so the sorted array remains sorted.
    - 做法就是不斷的將元素插入至既有的 sorted array 中正確的位置；
      而元素只有一項的 array 也算是 sorted array
- 範例 (由小到大排列)
  ```javascript
    function insertionSort(arr) {
        const LEN = arr.length;

        if (LEN === 1) { // 如果陣列長度為 1，則必為 sorted array，故直接回傳
            return arr;
        }

        for (let i = 1; i < LEN; i++) { // 由於僅有 1 項的陣列也算是 sorted array，因此毋須再判斷，所以迴圈才會從第 2 項開始跑

            const judgingElementValue = arr[i]; // 使用一個變數儲存 當前(這次迴圈中)要被排序的元素的值 // 因為這個值不會變動，故選用 const
            let pos = i; // 使用一個變數儲存 我要將這個被排序的元素插入至哪個位置(index) // 因為這個值可能會調整，故選用 let // 有點像是 pointer 的概念

            /* 
                1. 只要當前索引比 0 大，並且小於前一項的值，就
                    1-1. 將前一項的值，賦予給現在這個 index 的 value
                    1-2. pos--，這樣下次 while 迴圈的時候就可以從再往前一個 index 開始檢查

                2. 當 pos === 0，代表已經檢查到陣列的盡頭了，因此毋須再檢查
            */
            while (pos > 0 && judgingElementValue < arr[pos - 1]) {
                arr[pos] = arr[pos - 1]; // 將前一項的值，賦予給目前檢查的這個位置(index) // 等號(賦值運算子)的運算方向是右到左
                /* 
                    胡立的寫法是： [arr[pos], arr[pos - 1]] = [arr[pos - 1], arr[pos]];
                    但我認為沒必要將右邊那項的值賦予到左邊。
                    因為假如
                        1. 左邊的值，就是要插入的位置：
                           那我插入後就會覆寫啦
                        2. 還是要繼續往前找：
                           那下一次 while loop 的時候，就會被左邊的值賦值，也同樣會被覆寫；
                    所以我認為 將右邊那項的值賦予到左邊 這步是可以不用的。
                */
                pos--; // 下次 while 迴圈的時候就可以從再往前一個 index 開始檢查
            }
            arr[pos] = judgingElementValue; // 將正在排序元素的值賦予(插入)至正確的位置(index)
            // 如果切下去剛好最後一個值不用排，那就會變成 arr[i] = arr[i]，等同於沒有交換(也就是我們想要的效果)
        }

        return arr;
    }

    // const array1 = [1];
    // const array2 = [1, 2, 3, 4, 5];
    // const array3 = [3, 2, 1];
    // const array4 = [8, 9, 2, -100, 5, 1, 0, -3];
    // const array5 = [14, -4, 17, 6, 22, 1, 5];
    // const array6 = [14, -4];
    // console.log("insertionSort", insertionSort(array1));
    // console.log("insertionSort", insertionSort(array2));
    // console.log("insertionSort", insertionSort(array3));
    // console.log("insertionSort", insertionSort(array4));
    // console.log("insertionSort", insertionSort(array5));
    // console.log("insertionSort", insertionSort(array6));
  ```
- 演算法分析：
    - Worst Case Performance: O(n^2)
        - 由大到小 → 由小到大
    - Best Case Performance: O(n)
        - 遍歷陣列內所有元素一次後，發現剛好是都排列好的狀態
    - Average Case Performance: O(n^2)
    - 時間複雜度為： O(n^2)

### 50. ~ 52. Selection Sort
- The principle of selection sort is - select the smallest value in unsorted array, and then swap it with the left most value in the unsorted array.
    - 從 unsorted array 裡面找出最小值，並和 unsorted array 中最左邊那個互換，直到倒數第二個元素，因為最後只有一項的 array 也沒元素和他換
- 範例
  ```javascript
    function selectionSort(arr) {
        for (let i = 0; i <= arr.length - 2; i++) { // 檢查到倒數第二項即可，因為只有最後一項的 array 也沒元素和他換
            let minValIndex = i;
            for (let j = i + 1; j <= arr.length - 1; j++) { // 自己不用跟自己比，所以從自己的後面那項開始比
                if (arr[minValIndex] > arr[j]) {
                    minValIndex = j;
                }
            }
            
            // 互換方法 1
            // [[arr[i]], [arr[minValIndex]]] = [[arr[minValIndex]], [arr[i]]];
            // i 為 unsorted array 中最左邊那項
            
            // 互換方法 2
            let temp = arr[minValIndex];
            arr[minValIndex] = arr[i];
            arr[i] = temp;
        }
        return arr;
    }

    // const array1 = [1];
    // const array2 = [1, 2, 3, 4, 5];
    // const array3 = [3, 2, 1];
    // const array4 = [8, 9, 2, -100, 5, 1, 0, -3];
    // const array5 = [14, -4, 17, 6, 22, 1, 5];
    // const array6 = [14, -4];
    // console.log("selectionSort", selectionSort(array1));
    // console.log("selectionSort", selectionSort(array2));
    // console.log("selectionSort", selectionSort(array3));
    // console.log("selectionSort", selectionSort(array4));
    // console.log("selectionSort", selectionSort(array5));
    // console.log("selectionSort", selectionSort(array6));
  ```
- 演算法分析：
    - Worst Case Performance: O(n^2)
        - 由大到小 → 由小到大
    - Best Case Performance: O(n^2)
        - 因為每次迴圈仍然需要逐一確認是否為最小值，故仍為 O(n^2)
    - Average Case Performance: O(n^2)
    - 時間複雜度為： O(n^2)

### 綜合比較
以下說明皆針對，將陣列內的元素，由小到大排列(最左邊為最小)
- Bubble Sort
    - 從最後一個元素開始，不斷與當前待排序元素比較，將最小的值推到 unsorted array 最左邊
    - 雙重 for loop
- Insertion Sort
    - 從第二個開始，不斷將當前待排序的元素插入至已排序好的陣列中正確的位置
    - 因為只有一個元素的 array 必為 sorted array，所以才會從第二個元素開始
    - for loop + index + while loop
- Selection Sort
    - 從第一個開始，不斷的從 unsorted array 中挑出最小值，並與 unsorted array 中最左邊的值互換
    - 雙重 for loop + index


## ------------------------------------------------------------------------



## CH 6. Sorting Algorithms II

### 53. Intro to chapter 4

### 54. Merge Sort
- The principle of merge sort is quite simple. Take advantage of the fact that combining sorted arrays has O(n) time complexity, using the pointer skill.
- This sorting algorithm is a classic example of "divide and conquer".
- 只有一項元素的 array 必為 sorted array
- 放入之後 i(或 j) + 1，直到超過 arr.length - 1
    - 如果有其中一個已經超過 arr.length - 1，則直接將其餘的陣列全數放入新的陣列中
- 範例 2
  ```javascript
    /**
     * 將傳入的陣列合併
     * 如果傳入的陣列是由小到大，那合併後應該也要是由小到大
     * 傳入的陣列必須是 sorted array
     * @param {[]} arr1 傳入的第一個陣列
     * @param {[]} arr2 傳入的第二個陣列
     * @return {[]} 合併後排序好的陣列(如果傳入的陣列是由小到大，那合併後應該也要是由小到大)
     */
    function merge(arr1, arr2) {
        const res = [];
        let i = 0;
        let j = 0;
        while (i < arr1.length && j < arr2.length) {
            if (arr1[i] < arr2[j]) {
                res.push(arr1[i]);
                i++;
            }
            else {
                res.push(arr2[j]);
                j++;
            }
        }
        // 到這邊，會有其中一個陣列已經完全被加進陣列 res 中了
        
        // 下面這兩個 while loop 是為了把剩餘的元素加入至 res 中
        while (i < arr1.length) {
            res.push(arr1[i]);
            i++;
        }
        while (j < arr2.length) {
            res.push(arr2[j]);
            j++;
        }
        // console.log(`merge([${arr1}] | [${arr2}])`);
        return res;
    }

    function mergeSort(arr) {
        // 效果：不斷分割傳入的陣列(left 短 right 長，想要反過來也可以，反正最後都是要切到 1)，直到傳入的陣列長度為 1
        if (arr.length === 1) {
            return arr;
        }
        else {
            const middle = Math.floor(arr.length / 2);
            /* 
                arr.slice() 方法會回傳一個新陣列物件，為原陣列選擇之 begin 至 end（不含 end）部分的淺拷貝（shallow copy）；
                而原本的陣列將不會被修改。
                簡單講就是含頭不含尾
            */
            const left = arr.slice(0, middle);
            const right = arr.slice(middle, arr.length);
            // console.log("left", left);
            // console.log("right", right);
            return merge(mergeSort(left), mergeSort(right));
        }
    }

    // console.log("mergeSort", mergeSort([15, 3, 17, 18, 35, 11, 0, 36, -336, 1054]));
    // console.log("mergeSort", mergeSort([5, 3, 1, 6, 4, 2]));
    // console.log("mergeSort", mergeSort([1, 8, 2, 9, 5, 7]));
  ```
- 演算法分析：
    - 時間複雜度為： O(n．logⁿ)
    - 第 50 堂課，問答區裡面有個問題剛好是我所疑惑的
      "為何把陣列分割的過程(02:45-04:00)不算在運算步驟裡面呢？"
      因為分割和合併的步驟數必然相等，所以只需要算合併(或分割)的步驟數，然後再 * 2 就是總共的步驟數；
      又，Big O 的值是不受常數影響的，所以只要考量合併的 Big O 即可
      ![](https://i.imgur.com/rw2FX7o.png)
    - 總共合併 log₂ⁿ 層，每層合併需要 n 步
    - Worst Case Performance: O(n．logⁿ)
    - Best Case Performance: O(n．logⁿ)
    - Average Case Performance: O(n．logⁿ)
    - 無論甚麼狀況(即使原本已經排序好了也一樣)，merge sort 都是把傳入的陣列切成長度為 1 的小陣列之後再合併
    - merge sort 需要耗用較多的記憶體空間(因為這種寫法使用了遞迴，所以如果今天陣列的長度一大，那就很容易產生堆疊溢位)

### 59. Quick Sort
- partition
    - 小於 Pivot 的歸一類、大於 Pivot 的歸一類
- By itself, Partition is not a sorting algorithm, but it is an important subroutine of the Quicksort algorithm. So, to understand Quick sort, you must first understand Partition.
- The idea of partition is to divide the array into 2 parts. Either part is a sorted array, but the element in the middle is sorted (we found its correct final spot.)
- 需要用到雙重指標的技巧
- 演算法分析：
    - Worst Case Performance: O(n^2)
        -  pivot 永遠拿到最大或最小
    - Best Case Performance: O(n．logⁿ)
        -  pivot 剛好是中位數，將資料均分為二等分
    - Average Case Performance: O(n．logⁿ)




## ------------------------------------------------------------------------



## CH 9. Data Structure I

### 75. Intro to Data Structure
- 學習不同的資料結構，目的之一就是可以依據情境，降低演算法的時間複雜度
- CH 9. 會學 3 種
    1. Linked List
    2. Stack and Queue
    3. Hashtable

### 76. Linked List
- In computer science, a linked list is a linear collection of data elements whose order is not given by their physical placement in memory. Instead, each element points to the next.
- A data structure that contains only **head** and **length** property.
- Linked list consists of nodes, and each node has a **value** (number, string, array, or anything) and a **pointer to another or null**.
    - 如果是指向 null，則為該 linked list 的結尾
- Linked List has
    1. head
    2. length
    - each node has
        1. value
        2. pointer to another, or null
- JS 中的 array 不需直接指定陣列長度，因為 JS 會自動幫你做 space doubling
  (但像是 Java 中，如果要宣告一個陣列，那就需要先聲明這個陣列的長度)
- 在 linked list 中新增節點的方式
    1. 創建 node (每個 node 都會有 value, pointer)
    2. 將該 node 的 pointer 指向 null
    3. 將原本最後一個節點的 pointer，重新指向新創建的 node
    4. linked list 長度 +1

### 77. Advantages of Linked List
- Elements can be inserted into linked list indefinitely, while an array will eventually either fill up or need to be resized
    - Linked list 可以無限制的新增節點，但 array 則可能會被填滿，或者是需要調整陣列長度 (因為 Array 在被定義的時候，就需要先定義陣列長度)
- Very fast insertion and deletion comparted to Array.
    - 在 linked list 中，如果要新增、刪除節點，只需要動到相鄰的節點即可；
      但如果想要在 array 中新增、刪除節點，則基本上要動到整個陣列，將幾乎整個陣列往前，或往後挪移

### 78. Linked List Push
- 範例
  ```javascript
    class Node {
        constructor(value) {
            this.value = value;
            this.next = null;
        }
    }


    class LinkedList {
        
        constructor(value) {
            // 每個 linked list 都會有 head、length 屬性
            this.head = null;
            this.length = 0;
        }

        push(value) { // push：在資料結構的尾端新增一筆資料
            /* 
                步驟：
                    1. 創建一個新的 node
                    2. 將原本 linked list 尾端的 node，指向新創建的 node
                    3. 將原本 linked list 的長度 +1
            */

            // 1. 創建一個新的 node
            const newNode = new Node(value);

            if (this.length === 0) { // 代表目前新增的是第一項 
                // this.head === null 這種判斷方式也可以

                // 2. 將原本 linked list 尾端的 node 的 head 指向新創建的 node
                this.head = newNode;

                // 3. 將 linked list 的長度 +1
                this.length++;
            }
            else {
                // 2. 將原本 linked list 尾端的 node 的 head 指向新創建的 node

                // 目標：找到原本 linked list 尾端的 node

                // 從頭開始
                let currentNode = this.head;

                // 因為不確定要 loop 的次數，所以適合選用 while loop
                while (currentNode.next !== null) { 
                    // currentNode.next !== null 代表目前還沒有到資料結構的尾端
                    currentNode = currentNode.next; // 不斷尋找下一個 node
                }

                // 執行到這邊，currentNode 代表原本 linked list 尾端的 node
                currentNode.next = newNode; 
                // 因為 newNode 是一個物件，所以會傳參到 currentNode.next 中

                // 3. 將 linked list 的長度 +1
                this.length++;
            }
        }

        printAll() { // 印出所有 node
            if (this.length === 0) {
                console.log("Nothing in this Linked List");
                return;
            }
            else {
                let currentNode = this.head;
                while (currentNode !== null) {
                    console.log("currentNode.value", currentNode.value);
                    currentNode = currentNode.next;
                }
            }
        }
    }

    const myLinkedList = new LinkedList;
    myLinkedList.push("Harry");
    myLinkedList.push("Mike");
    myLinkedList.push("James");
    myLinkedList.push("Kevin");

    myLinkedList.printAll();
    console.log("myLinkedList.length", myLinkedList.length);
  ```
  ```javascript
    // 無註解版本

    push(value) { // push：在資料結構的尾端新增一筆資料
        /* 
            1. 創建一個新的 node
            2. 將原本 linked list 尾端的 node 指向新創建的 node
            3. 將 linked list 的長度 +1
        */
        const newNode = new Node(value);

        if (this.length === 0) {
            this.head = newNode;
        }
        else {
            let currentNode = this.head;
            while (currentNode.next !== null) {
                currentNode = currentNode.next;
            }
            currentNode.next = newNode;
        }
        this.length++;
    }
  ```
### 79. Linked List Pop
- 範例
  ```javascript
    pop() { // pop：移除資料結構的最後一筆資料
        // 既然是移除最後一筆，那就不需要傳入任何參數

        /* 
            步驟：
                1. 找到 linked list 倒數第二個 node
                   所以需要判斷倒數第二個 node 是否存在
                   1-1. 陣列長度為 0
                   1-2. 陣列長度為 1
                   1-3. 陣列長度 >= 2
                2. 將該 node 指向 null
                3. 將原本 linked list 的長度 -1
        */
        if (this.length === 0) {
            return undefined;
            // JS 中對一個空陣列進行 .pop()，會回傳 undefined
        }
        else if (this.length === 1) {
            const temp = this.head;
            /* 
                為什麼即使是物件，仍然可以把值鎖在 temp 裡面？

                因為當你在傳參考的當下，已經把記憶體位置傳給 temp，並藉由 const 的特性鎖定住了；
                因此接下來即便更動 this.head 的值，也不影響已經被鎖定住的記憶體位置
            */
            this.head = null;
            this.length = 0; // 原本長度為 1，所以邏輯其實一致
            return temp;
            // JS 中對一個陣列進行 .pop()，會回傳被移除的元素的值
        }
        else {
            let currentNode = this.head;

            // 利用 for 迴圈走到 倒數第二個
            for (let i = 0; i < this.length - 2; i++) {
                currentNode = currentNode.next;
            }

            const temp = currentNode.next;
            // 倒數第二個的下一個就是最後一個，也就是即將被移除的 node

            currentNode.next = null;
            this.length--;
            return temp;
        }
    }
  ```
  ```javascript
    // 無註解版本
    pop() { // pop：移除資料結構的最後一筆資料
        /* 
            步驟：
                1. 找到 linked list 倒數第二個 node
                   所以需要判斷倒數第二個 node 是否存在
                   1-1. 陣列長度為 0
                   1-2. 陣列長度為 1
                   1-3. 陣列長度 >= 2
                2. 將該 node 指向 null
                3. 將原本 linked list 的長度 -1
        */
        if (this.length === 0) {
            return undefined;
        }
        else if (this.length === 1) {
            const temp = this.head;
            
            this.head = null;
            this.length = 0;
            
            return temp;
        }
        else {
            let currentNode = this.head;
            for (let i = 0; i < this.length - 2; i++) {
                currentNode = currentNode.next;
            }
            const temp = currentNode.next;
            currentNode.next = null;
            this.length--;
            return temp;
        }
    }
  ```

### 80. Linked List Shift
- 範例
  ```javascript
    shift() { // shift：移除資料結構的第一筆資料
        /* 
            步驟：
                1. 找到 linked list 第二個 node
                   所以需要判斷第二個 node 是否存在
                   1-1. 陣列長度為 0
                   1-2. 陣列長度為 1
                   1-3. 陣列長度 >= 2
                2. 將該 node 指向 null
                3. 將原本 linked list 的長度 -1
        */

        if (this.length === 0) {
            return undefined; // JS 中對一個空陣列進行 .shift()，會回傳 undefined
        }
        else if (this.length === 1) {
            // 利用 oldFirstNode 暫存原本的第一個節點
            const oldFirstNode = this.head;
            this.head = null;
            this.length = 0;
            return oldFirstNode;
        }
        else {
            const oldFirstNode = this.head;
            oldFirstNode.head = null; // 不處理 oldFirstNode 的 head 指向也可以
            const newFirstNode = oldFirstNode.next;
            // 將 head 指向原本 linked list 中的第二個 node
            this.head = newFirstNode;
            this.length--;
            return oldFirstNode;
        }
    }
  ```


### 81. Linked List Unshift
- 範例
  ```javascript
    unshift(value) { // unshift：陣列開頭新增一個元素 
        // JS 中的 .unshift() 可以在陣列的開頭新增一個或多個元素，並回傳陣列的新長度
        // 未來可以自行練習 param 可接受以逗點隔開的方式傳入多個參數，並依序新增至 linked list 中

        /* 
            步驟：
                1. 創建一個新的 node
                2. 將 linked list 的開頭指向新創建的 node
                3. 將新創建的 node 指向原本的第一個節點
                4. 將原本 linked list 的長度 +1
        */

        // 1. 創建一個新的 node
        const newNode = new Node(value);

        if (this.length === 0) {
            // 2. 將 linked list 的開頭指向新創建的 node
            this.head = newNode;
        }
        else {
            // 利用 oldFirstNode 暫存原本的第一個節點
            const oldFirstNode = this.head;

            // 2. 將 linked list 的開頭指向新創建的 node
            this.head = newNode;

            // 3. 將新創建的 node 指向原本的第一個節點
            newNode.next = oldFirstNode;
        }

        // 3. 將原本 linked list 的長度 +1
        this.length++;
    }
  ```
  ```javascript
    // 無註解版本
    unshift(value) { // unshift：陣列開頭新增一個元素 
        /* 
            步驟：
                1. 創建一個新的 node
                2. 將 linked list 的開頭指向新創建的 node
                3. 將新創建的 node 指向原本的第一個節點
                4. 將原本 linked list 的長度 +1
        */

        const newNode = new Node(value);

        if (this.length === 0) {
            this.head = newNode;
        }
        else {
            const oldFirstNode = this.head;
            this.head = newNode;
            newNode.next = oldFirstNode;
        }
        this.length++;
    }
  ```

### 82. Linked List InsertAt
- 範例
  ```javascript
    insertAt(newPos, newValue) { // 在特定位置(從 0 起算) 插入新的值
        // 實際上在 linked list 的這種資料結構當中，是不存在 index 的

        /* 
            步驟：
                1. 判斷要插入的位置
                   1-1. 無法於 linked list 中找到相對應的插入位置
                   1-2. 插入至開頭 → unshift()
                   1-3. 插入至結尾 → push()
                   1-4. 其他
                        1-4-1. 創建一個新的 node
                        1-4-2. 利用 for 迴圈走到欲插入位置的前一個 node
                        1-4-3. 將新的 node 的 next 指向後一個 node
                        1-4-4. 將前一個 node 的 next 指向新的 node
                        1-4-5. 將原本 linked list 的長度 +1
        */

        if (newPos > this.length || newPos < 0) {
            console.log("無法於資料結構中找到相對應的插入位置");
            return;
        }
        else if (newPos === 0) {
            this.unshift(newValue);
            return;
        }
        else if (newPos === this.length) {
            this.push(newValue);
            return;
        }
        else {
            // 1-4-1. 創建一個新的 node
            const newNode = new Node(newValue);

            let currentNode = this.head;

            // 1-4-2. 利用 for 迴圈走到欲插入位置的前一個 node
            for (let i = 1; i <= newPos - 1; i++) {
                // 這邊 i 從 1 開始設定是因為目前 currentNode 已經指向 linked list 的第一個節點了
                currentNode = currentNode.next;
            }

            // 1-4-3. 將新的 node 的 next 指向後一個 node
            newNode.next = currentNode.next;

            // 1-4-4. 將前一個 node 的 next 指向新的 node
            currentNode.next = newNode;

            // 1-4-5. 將原本 linked list 的長度 +1
            this.length++;

            return;
        }
    }
  ```
  ```javascript
    // 無註解版本
    insertAt(newPos, newValue) { // 在特定位置(從 0 起算) 插入新的值
        // 實際上在 linked list 的這種資料結構當中，是不存在 index 的
        /* 
            步驟：
                1. 判斷要插入的位置
                   1-1. 無法於 linked list 中找到相對應的插入位置
                   1-2. 插入至開頭 → unshift()
                   1-3. 插入至結尾 → push()
                   1-4. 其他
                        1-4-1. 創建一個新的 node
                        1-4-2. 利用 for 迴圈走到欲插入位置的前一個 node
                        1-4-3. 將新的 node 的 next 指向後一個 node
                        1-4-4. 將前一個 node 的 next 指向新的 node
                        1-4-5. 將原本 linked list 的長度 +1
        */

        if (newPos > this.length || newPos < 0) {
            console.log("無法於資料結構中找到相對應的插入位置");
            return;
        }
        else if (newPos === 0) {
            this.unshift(newValue);
            return;
        }
        else if (newPos === this.length) {
            this.push(newValue);
            return;
        }
        else {
            const newNode = new Node(newValue);
            let currentNode = this.head;
            for (let i = 1; i <= newPos - 1; i++) {
                currentNode = currentNode.next;
            }
            newNode.next = currentNode.next;
            currentNode.next = newNode;
            this.length++;
            return;
        }
    }
  ```

### 83. Quick Fix
- 老師用於修正部分錯誤的範例程式碼

### 84. Linked List removeAt
- 範例
  ```javascript
    removeAt(removePos) { // 從特定位置(從 0 起算) 移除值
        /* 
            步驟：
                1. 判斷要刪除的位置
                   1-1. 無法於 linked list 中找到相對應的刪除位置
                   1-2. 刪除開頭 → shift()
                   1-3. 刪除結尾 → pop()
                   1-4. 其他
                        1-4-1. 利用 for 迴圈走到欲刪除位置的前一個 node
                        1-4-2. 將前一個 node 的 next 指向後一個位置的 node
                        1-4-3. 將原本 linked list 的長度 -1
        */

        if (removePos >= this.length || removePos < 0) {
            console.log("無法於資料結構中找到相對應的刪除位置");
            return;
        }
        else if (removePos === 0) {
            this.shift();
            return;
        }
        else if (removePos === this.length - 1) {
            this.pop();
            return;
        }
        else {
            let currentNode = this.head;

            // 1-4-1. 利用 for 迴圈走到欲刪除位置的前一個 node
            for (let i = 1; i <= removePos - 1; i++) {
                // 這邊 i 從 1 開始設定是因為目前 currentNode 已經指向 linked list 的第一個節點了
                currentNode = currentNode.next;
            }

            const removedNode = currentNode.next;

            // 1-4-2. 將前一個 node 的 next 指向後一個位置的 node
            currentNode.next = removedNode.next;

            removedNode.next = null; // 不處理欲刪除 node 的 next 指向也可以

            // 1-4-3. 將原本 linked list 的長度 -1
            this.length--;

            return;
        }
    }
  ```
  ```javascript
    // 無註解版本
    removeAt(removePos) { // 從特定位置(從 0 起算) 移除值
        /* 
            步驟：
                1. 判斷要刪除的位置
                   1-1. 無法於 linked list 中找到相對應的刪除位置
                   1-2. 刪除開頭 → shift()
                   1-3. 刪除結尾 → pop()
                   1-4. 其他
                        1-4-1. 利用 for 迴圈走到欲刪除位置的前一個 node
                        1-4-2. 將前一個 node 的 next 指向後一個位置的 node
                        1-4-3. 將原本 linked list 的長度 -1
        */

        if (removePos >= this.length || removePos < 0) {
            console.log("無法於資料結構中找到相對應的刪除位置");
            return;
        }
        else if (removePos === 0) {
            this.shift();
            return;
        }
        else if (removePos === this.length - 1) {
            this.pop();
            return;
        }
        else {
            let currentNode = this.head;
            for (let i = 1; i <= removePos - 1; i++) {
                currentNode = currentNode.next;
            }
            const removedNode = currentNode.next;
            currentNode.next = removedNode.next;
            removedNode.next = null; // 不處理欲刪除 node 的 next 指向也可以
            this.length--;
            return;
        }
    }
  ```
  
### 85. Linked List get
- 範例
  ```javascript
    get(pos) { // 取得特定位置的值
        /* 
            步驟：
                1. 判斷要取值的位置
                   1-1. 無法於 linked list 中找到相對應的取值位置
                   1-2. 其他
                        1-2-1. 利用 for 迴圈走到欲取值的位置
                        1-2-2. 取值
        */

        // 1-1. 無法於 linked list 中找到相對應的取值位置
        if (pos >= this.length || pos < 0) {
            // 相等也不行，因為最後一項的 index 就是 this.length - 1
            console.log("無法於資料結構中找到相對應的取值位置");
            return;
        }

        let currentNode = this.head;

        // 1-2-1. 利用 for 迴圈走到欲取值的位置
        for (let i = 0; i < pos; i++) {
            currentNode = currentNode.next;
        }

        // 1-2-2. 取值
        console.log("currentNode", currentNode);

        return;
    }
  ```
    ```javascript
    // 無註解版本
    get(pos) { // 取得特定位置的值
        /* 
            步驟：
                1. 判斷要取值的位置
                   1-1. 無法於 linked list 中找到相對應的取值位置
                   1-2. 其他
                        1-2-1. 利用 for 迴圈走到欲取值的位置
                        1-2-2. 取值
        */

        if (pos >= this.length || pos < 0) {
            console.log("無法於資料結構中找到相對應的取值位置");
            return;
        }

        let currentNode = this.head;
        for (let i = 0; i < pos; i++) {
            currentNode = currentNode.next;
        }
        console.log("currentNode", currentNode);

        return;
    }
    ```

### 86. Disadvantages of Linked Lists
- 從 77. 整理過來的
- They user more memory than array because of the storage used by their pointers.
- Nodes in a linked list must be read in order from the beginning as linked lists are inherently sequential access.
- Nodes are stored noncintiguous, greatly increasing the time periods required to access individual elements within the list, especially with a CPU cache.
- Difficulties arise in linked list when it comes to reverse traversing, For instance, singly-linked lists are cumbersome to navigate backward and while doubly linked list are womewhat easier to read, memory is consumed in allocating space for a back-pointer.

87. Overview of Linked List
- [比較：Array與Linked list](http://alrightchiu.github.io/SecondRound/linked-list-introjian-jie.html#:~:text=14%2D%3E3%2D%3E7%0A%7D%3B-,%E6%AF%94%E8%BC%83%EF%BC%9AArray%E8%88%87Linked%20list,-Array(%E7%9F%A9%E9%99%A3)%E4%B9%9F%E6%98%AF)

88. Doubly Linked List



## ------------------------------------------------------------------------


## CH 10. Data Structure II

### 103. Intro to Tree

### 104. Graph Definition
- In computer science, a graph is an abstract data type.
- A graph data type consists of a finite set(有限的集合) of vertices (also called nodes or points.)
-  Lines between nodes are known as edges (also called links or lines), and for a directed graph are also known as arrows.
    -  edges 可分為 
        - 單向 → Directed Graph
          ![](https://i.imgur.com/dBkatp5.png)
        - 雙向 → Undirected Graph
          ![](https://i.imgur.com/tDD0cGy.png)

### 105. Tree Definition
- Tree is a graph without a loop.
- Tree must have one and only one root.
- 例子：
    - ![](https://i.imgur.com/jZudVWQ.png)
    - DOM (Document Object Model)
    - File System in Operating System
    - Artificial Intelligence

### 106. Tree Traversal
- We need a systemetic way to know what nodes are in a tree.
    1. Breadth-First Tree Traversal
       廣度優先遍歷
    2. Depth-First Tree Traversal
       深度優先遍歷
       以下三種方法差異不大，掌握其一即可
       三者的主要差異在於，何時處理 root (還不是很懂)
       1. PreOrder
       2. InOrder
       3. PostOrder
        
### 107. Breadth-First Tree Traversal
- 一層一層找
  ![](https://i.imgur.com/zUD7bOc.png)
  [2, 7, 5, 2, 10, 6, 9, 5, 11, 4]

### 108. Depth-First Tree Traversal PreOrder
- 原則：root, left, right
  <!-- ![](https://i.imgur.com/VcFPb5G.png) -->
  ![](https://i.imgur.com/Q9nD9rL.png)
  [2, 7, 2, 10, 6, 5, 11, 5, 9, 4]

### 109. Depth-First Tree Traversal InOrder
- 還不是很懂
- 原則：left, root, right
  [2, 7, 10, 5, 6, 11, 2, 4, 9, 5]

### 110. Depth-First Tree Traversal PostOrder
- 還不是很懂
- 原則：left, right, root
  [2, 10, 5, 11, 6, 7, 4, 9, 5, 2]

### 112. Intro to Binary Search Tree (BST)
- 製造 hashtable 時，需要先知道有多少筆資料要儲存，用於計算 load factor
- Binary Tree: each node has at most two children, which are referred to as the left child and the right child.
- Binary Search Tree: a binary tree, but the left child is always less than the root, and the right child is always greater than the root.
  ![](https://i.imgur.com/q2yMtq6.png)

### 113. Constructing BST
- 給定一個陣列，製作出 BST
  [5, 7, 1, 15, 9, 2, 14, 8, 3]
  ![](https://i.imgur.com/3vLu4IH.png)

### 114. Pseudocode of Insertion in BST
- 還不是很懂

### 116. Traversal











### 139. Floyd Warshall Algorithm
- 找 任意兩點 間的最短距離
- 時間複雜度： O(n^3)



### 140. Dijkstra's Algorithm
- 找 指定點 與 圖中任一點 間的最短距離

 


